                .include "submodules/beeb/include/beeb.s65"
                .edef '\\','\'

fall_through_to: .macro dest
                .cerror *!=\dest,'fallthrough broke...'
                .endmacro

;-------------------------------------------------------------------------

default_vectors_ptr=$ffb7

os_a=$ef ; A value for osbyte/osword
os_x=$f0 ; X value for osbyte/osword
os_y=$f1 ; Y value for osbyte/osword

; seems to be relatively safe to use for brief periods with IRQs
; disabled
os_seiwk=$fa

; only safe to use with IRQs disabled!
os_seia=$fc

; 2 bytes unused on Electron. Used for the OSBYTE timeout.
elk_osbyte_81_timeout=$f8
                
; Fortunately the same on Electron OS 1.00 and Master MOS.
os_auto_repeat_countdown=$e7
os_auto_repeat_period=$255

; Routines that do PLA:<<restore ROM>>:PLA:PLP:RTS - as is part of the
; extended vector handling mechanism.
os_restore_rom_master=$ffa4
os_restore_rom_electron=$ff9c

;-------------------------------------------------------------------------

osbyte_var: .function index
                .cerror index<$a6||index>$ff,"bad OSBYTE"
                .endf $190+index


; MOS variables
os_tab_key_code=$26b            ;OSBYTE 219 ($db)

; 3 bytes for storing off the xvector/overlay info, so it can persist
; across BREAK.
;
; The first byte can't be $4c, but aside from that anything goes.
os_break_intercept=$287

os_last_break_type=osbyte_var($fd)

; 8 unused bytes! What a gift.
;
; Unlike page 2, this area persists across BREAK... but it's also
; overwritten by some games, so it's no good as working storage. So
; the ROM uses it to save its 7 bytes of state, plus a checksum, and,
; on boot, if the checksum matches, it reinitialises its working state
; with these values.
elk_persistent_state=$39f
                
;-------------------------------------------------------------------------
;
; See https://beebwiki.mdfs.net/OSBYTEs

; Placeholder OSBYTE used to indicate that the ROM is actually being
; entered due to KEYV.
keyv_osbyte_number=83

; Used to detect presence of ADJI hooks.
presence_osbyte_number=84

;-------------------------------------------------------------------------

brkbuf=$100

rom_name:='ADJI'
                .if single_fire_button
rom_name..=' (1F)'
                .endif
                .if debug
rom_name..=' (debug) '..build_time
                .endif
                
rom_ver='0.04'

default_overlay_address=$150
                
; Up=0, Down=1, Left=2, Right=3, Fire1=4, Fire2=5
                .if single_fire_button
num_actions=5
                .else
num_actions=6
                .endif

;-------------------------------------------------------------------------
;
; ROM state logical layout. Pass offsets into this struct into
; read_state/write_state.
; 
State: .struct
jflags: .block
                
; Index of joystick interface to use.
jindex_mask=%00000011
                
; If set, treat joystick inputs as keyboard inputs.
jkeys_mask=%00000100
                
; If set, treat joystick inputs as analogue inputs.
;
; This flag is tested with BIT, so the value is not arbitrary.
jjoy_mask=%01000000
                .fill 1
                .endblock
; Keys are stored as internal key numbers. See AUG p 142.
action_keys: .fill num_actions
                .endstruct
                .cerror State.jflags!=0,'State jflags must be at offset 0'

                ; The state has to fit into an 8-byte region.
                ; 
                ; On the Master, it has to go in the 8-byte name field
                ; of an FS info block, with 1 byte taken up by the 1st
                ; char of the name.
                ;
                ; On the Electron, it has to fit into the unused 8
                ; bytes at $39f, with 1 byte taken up by a checksum.
                .cerror size(State)>7,'State must be max 7 bytes'

;-------------------------------------------------------------------------
;
; ROM state on Master 128 is stored in a page in HAZEL. Layout just as
; per the struct.
;

hazel_state_addr=$df00

; OSBYTE 209 (&D1) is reserved for the speech system [MasRef D.2-67]
; master_spare=$0261

;-------------------------------------------------------------------------
;
; ROM state on Electron.
;
; The various bytes are stored in page 2, in locations that Electron
; OS 1.00 doesn't use.
;
; $0290 is used by the Slogger Electron Expansion ROM as follows:
;
; bit 6 = ADC/digital joystick select
; bits 0/1 = digital joystick index
;
; The ADJI ROM jflags are compatible.
;
; Also unused on Electron:
;
; $0261 - "speech suppression status" - unused in practice?
; $027F - used by MRB
; $0282 - used by MRB??
; $028a - used by MRB??
; $028b - used by MRB??
; 
elk_jflags=$0290                ;unused by Electron OS
elk_up=$02a8                    ;ROM flags for keyboard
elk_down=$02a9                  ;ROM flags for keyboard
elk_left=$02aa                  ;ROM flags for lower-priority BASIC
elk_right=$02f5                 ;unused by Electron OS
elk_fire1=$02f6                 ;unused by Electron OS
                .if !single_fire_button
elk_fire2=$027e                 ;unused by Electron OS
                .endif

;-------------------------------------------------------------------------

machine_type_other=0
machine_type_electron=1
machine_type_master=2

jup_mask=1
jdown_mask=2
jleft_mask=4
jright_mask=8
jfire1_mask=16
                .if single_fire_button
jall_fire_mask=jfire1_mask
                .else
jfire2_mask=32
jall_fire_mask=jfire1_mask|jfire2_mask
                .endif
                
jall_mask=jall_fire_mask|jright_mask|jleft_mask|jdown_mask|jup_mask
                
                
;-------------------------------------------------------------------------

struct_section: .macro
                .struct
                .dsection \1
                .ends
                .endmacro

*=$a8
                ; Leaf routines that only use transient zp workspace
                .union
                .endunion

                ; Leaf routines that return a result in zero page
                .union
                .struct_section strtoi_workspace
                .endunion

                ; * commands
                .union
                .struct_section cmd_jtest_workspace
                .struct_section cmd_jjoy_workspace
                .struct_section cmd_jkeys_workspace
                .struct_section cmd_jsetup_workspace
                .struct_section cmd_jstate_workspace
                .struct_section cmd_ddump_workspace
                .endunion
                
                .cerror *>$b0,'zp overflow'

;-------------------------------------------------------------------------

*=$b0
                ; Leaf routines that only use transient zp workspace
                ; and make no FS calls (or can survive their workspace
                ; being zapped if one is made).

                ; Leaf functions
                .union
                .struct_section print_following_string_workspace
                .struct_section reset_default_vectors_workspace
                .struct_section read_or_write_state_workspace
                .struct_section find_command_workspace
                .struct_section print_joystick_action_name_workspace
                .endunion
                
                .struct_section install_xvector_workspace
                .struct_section set_jkeys_mode_workspace
                .struct_section verbose_get_key_workspace
                .struct_section question_workspace
                .cerror *>$c0,'FS scratch zp overflow'

;-------------------------------------------------------------------------

*=$8000
                .dsection header
                .dsection tables
                .dsection service
                .dsection star
                .dsection common
                .dsection master_only
                .dsection electron_only
                .dsection library
                
                .if debug
                .dsection debug
                ; The debug ROM is for loading into sideways RAM or
                ; similar, and can occupy the full 16 KB.
                .cerror *>$b000-2,'code overflow'
debug_data:
                .cerror *>$c000,'debug overflow'
                .else
                ; The real ADJI ROM is 4 KB.
                .cerror *>$9000,'code overflow'
                .endif
                
;-------------------------------------------------------------------------
                .section header
;-------------------------------------------------------------------------

rom_header:
                .byte 0,0,0     ;language entry (none)
                jmp svc         ;service entry
                .byte $82       ;ROM type: service entry, 6502 code
                .byte <rom_copyright
                .byte 0
rom_title:
                .text rom_name
                .byte 0
rom_version:
                .text rom_ver
rom_copyright:
                .byte 0
                .text '('
sev_value:                      ;value with bit 6 set
                .text 'C) 2023 RH'
rom_copyright_end:
                .byte 0
;-------------------------------------------------------------------------
                .endsection header
;-------------------------------------------------------------------------
                .section tables
;-------------------------------------------------------------------------
command_table_entry: .function name,routine,help_offset
_start:
                .cerror (routine&$8000)==0,'routine address bit 15 must be set'
                .text name
                .byte >(routine-1)
                .byte <(routine-1)
                .byte help_offset
                .endfunction _start-command_table
                
command_table: .block
subjects_offset=*-command_table
                .command_table_entry "ADJI",help_adji,help_table.none_offset
                .byte 0
cmds_offset=*-command_table
                .command_table_entry "JJOY",cmd_jjoy,help_table.jjoy_offset
                .command_table_entry "JOFF",cmd_joff,help_table.none_offset
                .command_table_entry "JKEYS",cmd_jkeys,help_table.jkeys_offset
                .command_table_entry "JSETUP",cmd_jsetup,help_table.none_offset
                .if debug
                .command_table_entry "JSTATE",cmd_jstate,help_table.none_offset
                .endif
                .command_table_entry "JTEST",cmd_jtest,help_table.jtest_offset
                .if debug
                .command_table_entry "KTEST",cmd_ktest,help_table.none_offset
                .endif
                .if debug
                .command_table_entry "DRESET",cmd_dreset,help_table.none_offset
                .command_table_entry "DDUMP",cmd_ddump,help_table.none_offset
                .command_table_entry "DTEST",cmd_dtest,help_table.none_offset
                .endif
                .byte 0
                .endblock

help_table: .block
jtest_offset=*-help_table
                .text ' <n>'
none_offset=*-help_table
                .text 0
jjoy_offset=*-help_table
                .text ' <n> X|<addr>',0
jkeys_offset=*-help_table
                .text ' <n> <u> <d> <l> <r> <f1> '
                .if single_fire_button
                .text '<?>'
                .else
                .text '<f2>'
                .endif
                .text ' X|<addr>',0
                .endblock

;-------------------------------------------------------------------------

error_table_entry: .function err,text
_start:
                .byte err
                .text text
                .byte 0
                .endfunction _start-errors_table

errors_table: .block
bad_hex_offset: .error_table_entry $fe,'Bad hex'
incompatible_hw_offset: .error_table_entry $ff,'Electron/Master 128 only'
bad_jno_offset: .error_table_entry $dc,'Bad joystick'
bad_mode: .error_table_entry $ff,'Bad mode'
unexpected_os: .error_table_entry $ff,'Unexpected Electron OS'
                .endblock
                
;-------------------------------------------------------------------------

                .include "build/generated_key_tables.s65"

;-------------------------------------------------------------------------

joystick_actions: .block
masks:
                .byte jup_mask
                .byte jdown_mask
                .byte jleft_mask
                .byte jright_mask
                .byte jfire1_mask
                .if !single_fire_button
                .byte jfire2_mask
                .endif
names:
                ;      01234
                .text "     "
                .text "UP   "
                .text "DOWN "
                .text "LEFT "
                .text "RIGHT"
                .text "FIRE1"
                .if !single_fire_button
                .text "FIRE2"
                .endif
                .endblock

;-------------------------------------------------------------------------

elk_state_offsets: .proc
                .byte <elk_jflags
                .byte <elk_up
                .byte <elk_down
                .byte <elk_left
                .byte <elk_right
                .byte <elk_fire1
                .if !single_fire_button
                .byte <elk_fire2
                .endif
                .endproc
                
joystick_fred_offsets:
                .byte $c0,$d0,$e0,$f0

;-------------------------------------------------------------------------

questions_table: .proc
jno=*-questions_table
                .shiftl "Joystick no"
                .shiftl "1/2/3/4"
jk=*-questions_table
                .shiftl "Joystick/Keys"
                .shiftl "J/K"
xo=*-questions_table
                .shiftl "Xvector/Overlay"
                .shiftl "X/O"
                .endproc

;-------------------------------------------------------------------------

; copied from MOS 3.20
key_chars_table:
                .text "Q"                    ;10 q
                .byte "3"                    ;11 3
                .byte "4"                    ;12 4
                .byte "5"                    ;13 5
                .byte $84                    ;14 f4
                .text "8"                    ;15 8
                .byte $87                    ;16 f7
                .text "-"                    ;17 minus
                .text "^"                    ;18 caret
                .byte $8C                    ;19 left
                .byte "6"|$80                ;1a numpad_6
                .byte "7"|$80                ;1b numpad_7
                nop
                nop
                nop
                nop
                .cerror *-key_chars_table!=16,'oops'

                .byte $80                    ;20 f0
                .text "W"                    ;21 w
                .text "E"                    ;22 e 
                .text "T"                    ;23 t
                .text "7"                    ;24 7
                .text "I"                    ;25 i
                .text "9"                    ;26 9
                .text "0"                    ;27 0
                .text "_"                    ;28 underline
                .byte $8E                    ;29 down
                .byte "8"|$80                ;2a numpad_8
                .byte "9"|$80                ;2b numpad_9
                nop
                nop
                nop
                nop
                .cerror *-key_chars_table!=32,'oops'

                .text "1"                    ;30 1
                .text "2"                    ;31 2
                .text "R"                    ;33 r
                .text "6"                    ;34 6
                .text "D"                    ;32 d
                .text "U"                    ;35 u
                .text "O"                    ;36 o
                .text "P"                    ;37 p
                .text "["                    ;38 left_square_bracket
                .byte $8F                    ;39 up
                .byte "+"                    ;3a numpad_plus
                .byte "-"                    ;3b numpad_minus
                .byte $0d                    ;3c numpad_return
                nop
                nop
                nop
                .cerror *-key_chars_table!=48,'oops'
                
                .byte 1                      ;40 caps_lock
                .text "A"                    ;41 a
                .text "X"                    ;42 x
                .text "F"                    ;43 f
                .text "Y"                    ;44 y
                .text "J"                    ;45 j
                .text "K"                    ;46 k
                .text "@"                    ;47 at
                .text ":"                    ;48 colon
                .byte $0D                    ;49 return
                .byte "/"                    ;4a numpad_divide
                .byte 127                    ;4b numpad_delete
                .byte "."                    ;4c numpad_stop
                nop
                nop
                nop
                .cerror *-key_chars_table!=64,'oops'

                .byte 2                      ;50 shift_lock
                .text "S"                    ;51 s
                .text "C"                    ;52 c
                .text "G"                    ;53 g
                .text "H"                    ;54 h
                .text "N"                    ;55 n
                .text "L"                    ;56 l
                .text ";"                    ;57 semicolon
                .text "]"                    ;58 right_square_bracket
                .byte $7F                    ;59 delete
                .byte "#"                    ;5a numpad_hash
                .byte "*"                    ;5b numpad_multiply
                .byte ","                    ;5c numpad_comma
                nop
                nop
                nop
                .cerror *-key_chars_table!=80,'oops'

                .byte 0                      ;60 tab
                .text "Z"                    ;61 z
                .text " "                    ;62 space
                .text "V"                    ;63 v
                .text "B"                    ;64 b
                .text "M"                    ;65 m
                .text ","                    ;66 comma
                .text "."                    ;67 stop
                .text "/"                    ;68 divide
                .byte $8B                    ;69 copy
                .byte "0"                    ;6a numpad_0
                .byte "1"                    ;6b numpad_1
                .byte "3"                    ;6c numpad_3
                .byte 0                      ;6d
                .byte 0                      ;6e
                .byte 0                      ;6f
                .cerror *-key_chars_table!=96,'oops'

                .byte 27                     ;70 escape
                .byte $81                    ;71 f1
                .byte $82                    ;72 f2
                .byte $83                    ;73 f3
                .byte $85                    ;74 f5
                .byte $86                    ;75 f6
                .byte $88                    ;76 f8
                .byte $89                    ;77 f9
                .byte $5C                    ;78 backslash
                .byte $8D                    ;79 right
                .byte "4"                    ;7a numpad_4
                .byte "5"                    ;7b numpad_5
                .byte "2"                    ;7c numpad_2
                nop
                nop
                nop
                .cerror *-key_chars_table!=112,'oops'

;-------------------------------------------------------------------------
                .endsection tables
;-------------------------------------------------------------------------
                .section service
;-------------------------------------------------------------------------

                .if debug
svc_verbose=false
                .else
svc_verbose=false
                .endif
                
svc: .proc
                cmp #$15
                beq done2       ;fast path for 100 Hz polling
                                ;interrupt
                pha
                .if svc_verbose
                lda #'['
                jsr oswrch
                pla
                pha
                jsr print_hex_byte
                lda #']'
                jsr oswrch
                pla
                pha
                .endif
                cmp #4
                beq star
                cmp #9
                beq help
                cmp #$25
                beq store_fs_info

                ; Tube post-init seems as good a way as any of hooking
                ; into BREAK, regardless of ROM priority.
                ;
                ; On Master, it comes after the FS info is set up.
                cmp #$fe
                beq boot
unclaimed:
                pla
done:
                ldx $f4
done2:
                rts

claimed:
                pla
                lda #0
                beq done    ;i.e., JMP

store_fs_info: .proc
                .cpu '65c02'
                ; V=0 for hard reset, V=1 for soft reset
                clv
                tya             ;A=offset
                inc a           ;+1

                ; Always hard reset if not at the same location.
                cmp $df0,x
                sta $df0,x
                bne reset

                ; Always hard reset if not soft BREAK.
                lda osbyte_var($fd)
                bne reset

                ; V=1 for soft reset
                bit sev_value

reset:
                ldx #0
loop:
                bvc copy
                
                ; Don't overwrite the 7 state bytes.
                cpx #fs_info_block.spare_begin
                bcc copy
                cpx #fs_info_block.spare_end
                bcc next

copy:
                lda fs_info_block,x
                sta ($f2),y
next:
                iny
                inx
                cpx #11
                bne loop
                jmp unclaimed
                .cpu 'default'
                .endproc
                
help:
                tya
                pha
                jsr find_string_tail
                bcs no_help_subject ;taken if command line empty
                ldx #command_table.subjects_offset
                pla
                pha
                tay
                jsr find_command ;try to find subject
                bcc found_subject
                ; Command line not for us - do nothing and pass on.
pla_tay_unclaimed:
                pla
                tay
                jmp unclaimed

no_help_subject:
                jsr print_help_banner
                ldx #command_table.subjects_offset
                jsr print_help
                jmp pla_tay_unclaimed

found_subject:
                jsr print_help_banner
                sec
                jsr call_command_table_routine
                jmp pla_tay_unclaimed

star:
                tya
                pha
                ldx #command_table.cmds_offset
                jsr find_command
                bcc found_command
                jmp pla_tay_unclaimed
                
found_command:
                clc
                jsr call_command_table_routine
                pla
                tay
                jmp claimed

print_help_banner .proc
                jsr osnewl
                ldy #<rom_title
-
                lda rom_header,y
                bne +
                lda #' '
+
                jsr oswrch
                iny
                cpy #rom_copyright-rom_header
                bne -

                txa
                pha
                lda #presence_osbyte_number
                jsr osbyte
                cpx #'A'
                bne inactive
active:
                jsr print_following_string
                .text ' (active)',0
done:
                pla
                tax
                rts
inactive:
                jsr print_following_string
                .text ' (inactive)',0
                pla
                tax
                rts
                
                .endproc

boot: .proc
                tya
                pha
                
                lda os_last_break_type
                beq maybe_boot  ;taken if soft BREAK

                ; The policy is that power up or hard break cancels
                ; the JJOY or JKEYS state state.
                lda #0
                sta os_break_intercept+0
boot_done:
                pla
                tay
                jmp unclaimed

maybe_boot:
                jsr is_valid_hw
                bcc boot_done
                bvs maybe_boot_2

                ; Try to copy state from persistent area.
                ldy #size(State)-1
                lda #0
                pha
reinstate_loop:
                pla
                clc
                adc elk_persistent_state+1,y
                pha
                lda elk_persistent_state+1,y
                jsr write_state
                dey
                bpl reinstate_loop

                pla
                cmp elk_persistent_state+0
                bne @b boot_done ;taken if persistent state is bogus

maybe_boot_2:
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask|State.jflags.jjoy_mask
                beq @b boot_done   ;taken if neither *JJOY nor *JKEYS

                ldy #State.action_keys
loop:
                jsr read_state
                bmi @b boot_done   ;taken if obviously invalid key
                iny
                cpy #State.action_keys+num_actions
                bne loop

                lda os_break_intercept+0
                cmp #'X'
                beq xvector

overlay:
                cmp #'O'
                bne @b boot_done

                lda os_break_intercept+2
                sta strtoi_value+1
                .if debug
                jsr print_hex_byte
                .endif
                lda os_break_intercept+1
                sta strtoi_value+0
                .if debug
                jsr print_hex_byte
                .endif
                jsr install_overlay
                jmp boot_done

xvector:
                lda os_break_intercept+1
                cmp #'X'
                bne @b boot_done
                lda os_break_intercept+2
                cmp #'X'
                bne @b boot_done
                jsr install_xvector
                jmp boot_done
                .endproc
                
                .endproc

fs_info_block: .block
                .text '*'       ;extremely bogus...
spare_begin=*-fs_info_block
                .fill 7,' '
spare_end=*-fs_info_block
                .text 1,2,1     ;CFS values
                .endblock
                
;-------------------------------------------------------------------------

help_adji: .proc
                ldx #command_table.cmds_offset
                jmp print_help
                .endproc

;-------------------------------------------------------------------------
;
; Print help for part of the commands table.
;
; Entry: X = offset of first command
;
print_help: .proc
                jsr osnewl
cmds_loop:
                lda command_table,x
                beq done
                lda #' '
                jsr oswrch
                jsr oswrch
cmd_name_loop:
                lda command_table,x
                bmi name_done
                jsr oswrch
                inx
                bne cmd_name_loop
name_done:
                inx
                inx
                ldy command_table,x
                inx
help_loop:
                lda help_table,y
                beq next
                jsr oswrch
                iny
                bne help_loop
next:
                jsr osnewl
                jmp cmds_loop
done:
                rts
                .endproc
;-------------------------------------------------------------------------
                .endsection service
;-------------------------------------------------------------------------
                .section star
;-------------------------------------------------------------------------

; TODO could live in keyboard table
cmd_joff:
                jsr reset_default_vectors
                rts

;-------------------------------------------------------------------------
                
cmd_jjoy: .proc
                .section cmd_jjoy_workspace
joystick_index: .fill 1
yval: .fill 1
                .endsection

                jsr must_be_valid_hw

                jsr reset_default_vectors

                jsr parse_jno
                sta joystick_index

                sty yval

                lda joystick_index
                ora #State.jflags.jjoy_mask
                jsr set_jflags

                jsr elk_persist_state
                
                ldy yval
                .fall_through_to handle_install_mode
                .endproc

handle_install_mode: .proc
                jsr find_string_tail
                bcc +

                ldx #errors_table.bad_mode
                jmp do_error

+
                and #$df
                cmp #'X'
                beq install_xvector
                jsr strtoi
                jmp install_overlay
                .endproc

;-------------------------------------------------------------------------

cmd_jkeys: .proc
                .section cmd_jkeys_workspace
index: .fill 1
yval: .fill 1
state_index: .fill 1
                .endsection

                jsr must_be_valid_hw
                jsr reset_default_vectors

                jsr parse_jno
                sty yval

                ora #State.jflags.jkeys_mask
                jsr set_jflags

                lda #State.action_keys
                sta index

loop:
                ldy yval
                jsr strtoi
                sty yval

                ; convert to internal key number
                eor #$ff

                ; bit 7 must be clear! Some of these values are stored
                ; in the ROM status bytes, and bit 7 implies that bank
                ; is a valid ROM with a a service entry...
                and #$7f

                ldy index
                jsr write_state

                iny
                sty index
                cpy #State.action_keys+num_actions
                bne loop

                jsr elk_persist_state

                ldy yval

                .if single_fire_button
                ; Discard FIRE2 setting
                jsr strtoi
                .endif
                
                jmp handle_install_mode
                .endproc

;-------------------------------------------------------------------------

cmd_jsetup: .proc
input_block=$150
input_buffer=$155
                .section cmd_jsetup_workspace
jno: .fill 1
jkeys: .fill 1
use_overlay: .fill 1
action_index: .fill 1
                
                .endsection

                jsr reset_default_vectors

                ldx #questions_table.jno
                jsr question
                bcs done
                sty jno

                ldx #questions_table.jk
                jsr question
                bcs done
                sty jkeys
                tya
                bne keys        ;taken if keys

joy:
                jsr hook_question

                bit $ff
                bmi done
                
                jsr print_following_string
                .text '*JJOY ',0

                jsr print_jno
                jsr print_hook_info
install:
                lda jno
                ora #State.jflags.jjoy_mask ;assume joystick mode
                ldx jkeys
                beq +           ;taken if joystick mode

                ; clear jjoy flag, set jkeys flag
                eor #State.jflags.jjoy_mask|State.jflags.jkeys_mask
+
                jsr set_jflags
                jsr elk_persist_state
                lda use_overlay
                beq install_xvector
                jmp install_overlay

keys:
                lda #0
                sta action_index
actions_loop:
                jsr print_following_string
                .text 'Press ',0

                ldx action_index
                jsr print_joystick_action_name

                jsr print_following_string
                .text ': ',0

                jsr verbose_get_key

                bit $ff
                bmi done

                jsr osnewl

                clc
                lda action_index
                adc #State.action_keys
                tay             ;Y=state offset

                txa             ;A=INKEY
                eor #$ff        ;A=internal key value
                jsr write_state

                inc action_index
                lda action_index
                cmp #num_actions
                bne actions_loop

                ; Clear buffers
                lda #15
                ldx #0
                jsr osbyte

                jsr hook_question

                bit $ff
                bmi done

                ; Print *JKEYS command line
                jsr print_following_string
                .text '*JKEYS ',0

                lda jno
                clc
                adc #'1'
                jsr oswrch

                ldx #State.action_keys
print_keys_loop:
                jsr print_following_string
                .text ' &',0

                txa
                tay
                jsr read_state
                eor #$ff        ;convert to negative INKEY value
                jsr print_hex_byte

                inx
                cpx #State.action_keys+num_actions
                bne print_keys_loop

                .if single_fire_button
                jsr print_following_string
                .text ' 0',0
                .endif

                jsr print_hook_info
                jmp install
                
done:
                rts

hook_question:
                ldx #questions_table.xo
                jsr question
                bcs done
                sty use_overlay
                cpy #0
                beq done        ;bail if xvector

                jsr print_following_string
                .text 'Overlay addr (default: &',format('%X',default_overlay_address),'): ',0

                ; seems to be usual to put the parameter block in main
                ; RAM, rather than referring to one in the ROM?
                ldy #4
-
                lda osword_block,y
                sta input_block,y
                dey
                bpl -

                ldx #<input_block
                ldy #>input_block
                lda #0
                jsr osword
                bcs done

                lda #<default_overlay_address
                sta strtoi_value+0
                lda #>default_overlay_address
                sta strtoi_value+1
                
                lda #<input_buffer
                sta $f2
                lda #>input_buffer
                sta $f3
                ldy #0
                jsr find_string_tail
                bcs done        ;taken if empty input - use default
                jmp strtoi
                
print_jno:
                lda jno
                clc
                adc #'1'
                jmp oswrch

print_hook_info:
                lda #' '
                jsr oswrch
                lda use_overlay
                bne print_overlay_addr
                ; using xvector
                lda #'X'
                jsr oswrch
                jmp osnewl
print_overlay_addr:
                lda #'&'
                jsr oswrch
                lda strtoi_value+1
                jsr print_hex_byte
                lda strtoi_value+0
                jsr print_hex_byte
                jmp osnewl

osword_block:
                .word input_buffer ;buffer address
                .byte 5            ;max length
                .byte 32           ;min ASCII
                .byte 127          ;max ASCII
                
                .endproc
;-------------------------------------------------------------------------

cmd_jtest: .proc
                .section cmd_jtest_workspace
joystick_index: .fill 1
action_index: .fill 1
jvalue: .fill 1
                .endsection
                
                jsr parse_jno
                sta joystick_index
                
                jsr print_following_string
                .text 22,135
                .text 31,14,1
                .text "JOYSTICK TEST"
                .byte 0

                jsr coff

loop:
                bit $ff
                bmi done        ;taken if Escape pressed

                ldx joystick_index
                jsr read_joystick
                sta jvalue

                ; 01234567890123456789012345
                ; Raw value: &xx (%xxxxxxxx)

                jsr print_following_string
                .text 31,8,5,"Raw value: &",0

                lda jvalue
                jsr print_hex_byte

                jsr print_following_string
                .text " (%",0

                ldx #8
                ldy jvalue
binary_loop:
                tya
                asl a
                tay

                lda #'0'
                adc #0
                jsr oswrch

                dex
                bne binary_loop

                jsr print_following_string
                .text ")",0

                lda #num_actions-1
                sta action_index
check_actions:
                
                jsr print_following_string
                .byte 31,17,0
                
                lda action_index
                clc
                adc #10         
                jsr oswrch      ;PRINT TAB(17,Y)

                lda jvalue

                ldx action_index
                and joystick_actions.masks,x
                bne +
                ldx #$ff        ;no action
+
                jsr print_joystick_action_name

                dec action_index
                bpl check_actions
                jmp loop

done:
                jsr con
                lda #$7e
                jsr osbyte
                lda #12
                jmp oswrch
                
                .endproc

;-------------------------------------------------------------------------

cmd_ktest: .proc
                jsr print_following_string
                .text 'Press keys',0

ktest_loop:
                jsr print_following_string
                .text ' | ',0

                jsr verbose_get_key

                bit $ff
                bpl ktest_loop

                lda #15
                ldx #0
                jmp osbyte
                
                .endproc

;-------------------------------------------------------------------------

cmd_jstate: .proc
                .section cmd_jstate_workspace
index: .fill 1
                .endsection
                
                lda #0
                sta index
loop:
                jsr print_following_string
                .text '+&',0

                lda index
                jsr print_hex_byte

                lda #' '
                jsr oswrch

                ldx #$ff
                lda index
                cmp #State.action_keys
                bcc print_name
                sbc #State.action_keys
                tax
print_name:
                jsr print_joystick_action_name

                jsr print_following_string
                .text ': &',0

                ldy index
                jsr read_state
                jsr print_hex_byte
                tax

                lda #' '
                jsr oswrch

                lda index
                cmp #State.jflags
                beq print_jflags
                cmp #State.action_keys
                bcc next

                ldy #0
                txa
                eor #$7f
find_key_name:
                and #$7f
                cmp key_inkey_numbers_table,y
                beq char_name_key
                ora #$80
                cmp key_inkey_numbers_table,y
                beq string_name_key
                iny
                cpy #num_master_keys
                bne find_key_name

                lda #'?'
                jsr oswrch

next:
                jsr osnewl
                inc index
                lda index
                cmp #size(State)
                bne loop

                jsr print_following_string
                .text 'KEYV=&',0

                ldx #<keyv
                jsr print_vector

                jsr print_following_string
                .text 10,13,'BYTEV=&',0

                ldx #<bytev
                jsr print_vector

                jsr osnewl
                
                rts

print_vector:
                lda $201,x
                jsr print_hex_byte
                lda $200,x
                jmp print_hex_byte

char_name_key:
                lda key_names_table,y
                jsr oswrch
                jmp next

string_name_key:
                ldx key_names_table,y
-
                lda key_strings_table,x
                jsr shiftl_oswrch
                inx
                bcc -
                jmp next

print_jflags:
                jsr print_following_string
                .text 'jindex=',0

                txa
                and #State.jflags.jindex_mask
                jsr print_hex_byte.nybble

                jsr print_following_string
                .text ' jkeys=',0

                txa
                and #State.jflags.jkeys_mask
                jsr print_bool

                jsr print_following_string
                .text ' jjoy=',0
                txa
                and #State.jflags.jjoy_mask
                jsr print_bool
                jmp next
                
                .endproc
                
;-------------------------------------------------------------------------
                .endsection star
;-------------------------------------------------------------------------
                .section common
;-------------------------------------------------------------------------
;
; Install overlay routines.
;
; Entry: (strtoi_value) = dest pointer
;        state jflags
; 
install_overlay: .proc
                jsr must_be_valid_hw
                bvs master

electron:
                ; Check the ROM is at least roughly as expected...
                lda os_restore_rom_electron+0
                cmp #$68        ;PLA
                bne os_wut 
                lda os_restore_rom_electron+1
                cmp #$20        ;JSR abs
                bne os_wut
                
                ldy #size(overlay_electron)-1
electron_loop:
                lda overlay_electron,y
                sta (strtoi_value),y
                dey
                bpl electron_loop

                ; Fix up ROM bank.
                ldy #overlay_electron.rom_offset
                lda $f4
                sta (strtoi_value),y

                ; Point BYTEV to the right place.
                lda #overlay_electron.osbyte_entry_offset
                jsr set_overlay_bytev

                ; Maybe point KEYV to the right place.
                ldx #overlay_electron.keyv_entry_offset
                jsr maybe_set_overlay_keyv

                jmp note_overlay_address

os_wut:
                ldx #errors_table.unexpected_os
                jmp do_error
                
master:
                ldy #size(overlay_master)-1
master_loop:
                lda overlay_master,y
                sta (strtoi_value),y
                dey
                bpl master_loop

                ; Fix up ROMSEL value.
                ldy #overlay_master.rom_offset
                lda $f4
                sta (strtoi_value),y

                ; Fix up workspace page.
                tay
                lda $df0,y
                ldy #overlay_master.hazel_offset
                sta (strtoi_value),y

                ; Point BYTEV to the right place.
                lda #overlay_master.osbyte_entry_offset
                jsr set_overlay_bytev

                ; Maybe point KEYV to the right place.
                ldx #overlay_master.keyv_entry_offset
                jsr maybe_set_overlay_keyv

note_overlay_address:
                lda #'O'
                sta os_break_intercept+0
                lda strtoi_value+0
                sta os_break_intercept+1
                lda strtoi_value+1
                sta os_break_intercept+2

                rts
                
maybe_set_overlay_keyv:
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq overlay_vector_set
                txa
                ldx #<keyv
                bne set_overlay_vector ;always taken
set_overlay_bytev:
                ldx #<bytev
set_overlay_vector:
                php
                sei
                clc
                adc strtoi_value+0
                sta $200,x
                lda strtoi_value+1
                adc #0
                sta $201,x
                plp
overlay_vector_set:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Install xvector routines.
;
; Entry: state jflags
install_xvector: .proc
                .section install_xvector_workspace
xvectors: .fill 2
                .endsection
                lda osbyte_var($a8)
                sta xvectors+0
                lda osbyte_var($a9)
                sta xvectors+1

                jsr must_be_valid_hw
                ldx #0          ;assume Master
                bvs +           ;taken if Master 128
                ldx #2          ;Electron
+
                php
                sei

                ; BYTEV
                lda #$ff
                sta bytev+1
                ldy #(<bytev)/2*3
                sty bytev+0
                lda bytev_values+0,x
                sta (xvectors),y
                iny
                lda bytev_values+1,x
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y

                ; KEYV
                ldy #State.jflags
                jsr read_state
                and #State.jflags.jkeys_mask
                beq keyv_done

                lda #$ff
                sta keyv+1
                ldy #(<keyv)/2*3
                sty keyv+0
                lda keyv_values+0,x
                sta (xvectors),y
                iny
                lda keyv_values+1,x
                sta (xvectors),y
                iny
                lda $f4
                sta (xvectors),y
keyv_done:

                lda #'X'
                sta os_break_intercept+0
                sta os_break_intercept+1
                sta os_break_intercept+2
                
                plp
                rts

bytev_values:
                .word handle_osbyte_xvector_master
                .word handle_osbyte_electron.osbyte_xvector_entry

keyv_values:
                .word handle_keyv_xvector_master
                .word handle_keyv_xvector_electron
                
                .endproc
;-------------------------------------------------------------------------
                .endsection common
;-------------------------------------------------------------------------
                .section electron_only
;-------------------------------------------------------------------------
; 
; Save Electron state
;
; Preserves: X
; 
elk_persist_state: .proc
                .cerror size(State)>7,'oops'
                jsr is_valid_hw
                bvs done        ;skip when Master
                lda #0
                sta elk_persistent_state+0
                ldy #size(State)-1
loop:
                jsr read_state
                sta elk_persistent_state+1,y
                clc
                adc elk_persistent_state+0
                sta elk_persistent_state+0
                dey
                bpl loop
done:
                rts
                .endproc

;-------------------------------------------------------------------------

overlay_electron: .block
keyv_entry_offset=*-overlay_electron
                lda #keyv_osbyte_number
osbyte_entry_offset=*-overlay_electron
                php             ;P RetL RetH
                sei
                pha             ;A P RetL RetH
                lda #12
                sta $fe05
rom_offset=*+1-overlay_electron
                lda #$ff
                sta $fe05
                jmp handle_overlay_electron
                .endblock
                .cerror size(overlay_electron)>128,'Electron overlay too large'

;-------------------------------------------------------------------------

handle_overlay_electron:
                ; Save this ROM bank.
                sta os_seiwk+1

                ; Save input A.
                pla             ;P RetL RetH
                sta os_seiwk+0

                ; Save input P.
                pla             ;RetL RetH
                sta os_seia

                ; Save previous ROM.
                lda $f4
                pha             ;ROMSEL RetL RetH

                ; Fix up $f4.
                lda os_seiwk+1
                sta $f4

                ; Insert overlay exit routine address
                lda #>handle_overlay_exit_electron-1
                pha             ;ExitH ROMSEL RetL RetH
                lda #<handle_overlay_exit_electron-1
                pha             ;ExitL ExitH ROMSEL RetL RetH

                ; Put input P back on stack. Don't possibly re-enable
                ; IRQs just yet - A is still in os_seiwk.
                lda os_seia
                pha             ;P ExitL ExitH ROMSEL RetL RetH

                ; Reinstate input A.
                lda os_seiwk+0

                jmp handle_osbyte_electron

; Entry: A/X/Y/P as per OSBYTE/KEYV return
; Stack: ROMSEL RetL RetH
handle_overlay_exit_electron:
                pha             ;A ROMSEL RetL RetH
                php             ;P A ROMSEL RetL RetH
                txa
                pha             ;X P A ROMSEL RetL RetH
                tsx             ;| X P A ROMSEL RetL RetH
                lda $104,x      ;ROMSEL
                pha             ;ROMSEL | X P A ROMSEL RetL RetH
                lda $102,x      ;P
                sta $104,x      ;ROMSEL | X P A P RetL RetH
                pla             ;| X P A P RetL RetH
                sta $102,x      ;| X ROMSEL A P RetL RetH
                pla             ;ROMSEL A P RetL RetH
                tax
                jmp os_restore_rom_electron

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV handler for Electron.
;
; Entry: A, X, Y = OSBYTE/KEYV arguments
;        Stack = [P RetL RetH]

handle_osbyte_electron: .proc
                ; Don't use the OSBYTE zero page yet - this call might
                ; be KEYV.
                cmp #keyv_osbyte_number
                bne is_osbyte
                jmp keyv_electron

osbyte_xvector_entry:
                php
is_osbyte:
                sta os_a
                stx os_x
                sty os_y

                cmp #$80
                beq osbyte_80_electron

                cmp #$81
                beq osbyte_81_electron

                cmp #presence_osbyte_number
                beq osbyte_presence_generic

unhandled:
                ldx os_x
unhandled_got_x:
                ldy os_y
                jmp jmp_default_osbyte.with_p_already_pushed
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE $81 handler for Electron.
;
; Entry: A = $81, ?os_a = $81
;        ?os_x, ?os_y = OSBYTE $81 entry arguments
;       Stack = [P RetL RetH]

osbyte_81_electron: .proc
                ; Skip if jkeys bit not set.
                lda elk_jflags
                and #State.jflags.jkeys_mask
                cmp #1          ;C=1 if set

                ; Defer to default OSBYTE if jkeys off.
                ldx os_x
                lda os_a
                ldy os_y
                bcc jmp_default_osbyte.with_p_already_pushed

                ; Go to timeout case if Y<$80
                bpl timeout

                ; Call default OSBYTE if Y!=$ff
                cpy #$ff
                bne jmp_default_osbyte.with_p_already_pushed

                ; Call default OSBYTE for the X=$00 Y=$FF version
                ; call.
                cpx #0
                beq jmp_default_osbyte.with_p_already_pushed

                ; Is this one of the jkeys?
                lda os_x
                eor #$ff        ;convert to internal key

                ldx #num_actions-1 ;X=action index
poll_key_loop:
                ldy elk_state_offsets+State.action_keys,x
                cmp $200,y
                beq found_key
                dex
                bpl poll_key_loop
not_found_key:
                lda #$81
                ldy #$ff
                ldx os_x
                jmp jmp_default_osbyte.with_p_already_pushed

found_key:
                lda elk_jflags
                and #3
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                and joystick_actions.masks,x
                beq not_found_key

                ldx #$ff
                ldy #$ff
                lda #$81
                plp
                rts

timeout:
                plp
                
                ; Form timeout.
                stx elk_osbyte_81_timeout+0
                sty elk_osbyte_81_timeout+1
loop:
                ; Read joystick
                lda elk_jflags
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and #jall_mask
                beq try_osbyte  ;taken if obviously nothing pressed

                ; Find state offset for action.
                ldy #State.action_keys-1
find_index_loop:
                iny
                lsr a
                bcc find_index_loop

                ldx elk_state_offsets,y
                ldy $200,x
                bpl jkey_pressed

try_osbyte:
                ; assume remaining timeout >0
                ldy #0
                ldx #1
                lda elk_osbyte_81_timeout+0
                ora elk_osbyte_81_timeout+1
                bne call_osbyte_81
                dex             ;X=0,Y=0
call_osbyte_81:
                lda #$81
                jsr jmp_default_osbyte
                cpy #$ff
                bne kkey_pressed

next:
                lda elk_osbyte_81_timeout+0
                bne no_carry
                lda elk_osbyte_81_timeout+1
                beq timed_out
                dec elk_osbyte_81_timeout+1
no_carry:
                dec elk_osbyte_81_timeout+0
                jmp loop

timed_out:
                ; Timed out. Return with C=1 and Y=$ff
                ldy #$ff
                sec
                rts

kkey_pressed:
                rts

jkey_pressed:
                cpy #16
                bcc try_osbyte        ;definitely not ASCII
                lda key_chars_table-16,y ;X=ASCII value of key pressed
                bmi try_osbyte        ;bail if not ASCII
                beq try_osbyte        ;bail if TAB
                
                ldx os_auto_repeat_countdown
                beq reset_auto_repeat_countdown
                dec os_auto_repeat_countdown
                bne try_osbyte
reset_auto_repeat_countdown:
                ldx os_auto_repeat_period
                stx os_auto_repeat_countdown

                tax                   ;X=ASCII value of key pressed
                lda os_a
                ldy #0
                clc
                rts
               
               .endproc

;-------------------------------------------------------------------------
;
; OSBYTE $80 handler for Electron.
;
; Entry: A = $80, ?os_a = $80
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        Stack = [P RetL RetH]
;
osbyte_80_electron: .proc
                ; Bail if not ADVAL.
                ldx os_x
                cpx #5
                bcs handle_osbyte_electron.unhandled_got_x

                ; Bail if not jjoy mode.
                bit elk_jflags
                bvc handle_osbyte_electron.unhandled_got_x

                ; Fetch joystick index.
                lda elk_jflags
                and #3

                ; ?os_a = joystick value
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                sta os_a

                plp
                jmp osbyte_80_generic
                .endproc

;-------------------------------------------------------------------------
;
; KEYV handler for Electron.
;
; Entry: A = any
;        X, Y = KEYV arguments
;        Stack = [P RetL RetH]
keyv_electron:
                plp
                .fall_through_to handle_keyv_xvector_electron

;-------------------------------------------------------------------------
;
; Extended vector KEYV handler for Electron.
;
; Entry: A = any
;        X, Y, P = KEYV arguments
handle_keyv_xvector_electron: .proc
                php
                bvs +                  ;eliminate V=1 case
                bcs escan               ;handle C=1 V=0 case
+
                jmp jmp_default_keyv.with_p_already_pushed

escan:
                txa
                bpl escan_multiple_keys

                sei
                
                and #$7f        ;internal key number
                sta os_seiwk+0

                lda elk_jflags
                and #State.jflags.jindex_mask
                tay
                ldx joystick_fred_offsets,y
                ldy $fc00,x

                ldx os_seiwk+0  ;internal key number

test_up:
                cpx elk_up
                bne test_down
                tya
                and #jup_mask
                bne pressed

test_down:
                cpx elk_down
                bne test_left
                tya
                and #jdown_mask
                bne pressed

test_left:
                cpx elk_left
                bne test_right
                tya
                and #jleft_mask
                bne pressed

test_right:
                cpx elk_right
                bne test_fire1
                tya
                and #jright_mask
                bne pressed

test_fire1:
                cpx elk_fire1
                bne test_fire2
                tya
                and #jfire1_mask
                bne pressed

test_fire2:
                .if !single_fire_button
                cpx elk_fire2
                bne pass_to_keyv
                tya
                and #jfire2_mask
                bne pressed
                .endif

pass_to_keyv:
                lda os_seiwk+0  ;internal key number
                ora #$80        ;reinstate bit 7, masked out above
                tax
                jmp jmp_default_keyv.with_p_already_pushed
                
pressed:
                ldx #$ff
                txa
                plp
                rts

escan_multiple_keys:
                txa
                pha
                sec
                clv
                jsr jmp_default_keyv

                sei

                ; Save KEYV input - min key.
                pla
                sta os_seiwk+0
                
                ; Save KEYV result - max key.
                stx os_seiwk+1

                lda elk_jflags
                and #State.jflags.jindex_mask
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                sta os_seia     ;joystick state

                ldx #num_actions-1
loop:
                lda os_seia     ;joystick state
                and joystick_actions.masks,x
                beq next        ;taken if not pressed

                lda elk_state_offsets+State.action_keys,x
                tay
                lda $200,y
                cmp os_seiwk+0  ;within scan range?
                bcc next        ;taken if not
                beq next        ;taken if not
                cmp os_seiwk+1  ;existing result covers it?
                bcs next        ;taken if so
                
                sta os_seiwk+1

next:
                dex
                bpl loop

                ldx os_seiwk+1
                txa
                plp
                rts
                .endproc
                
;-------------------------------------------------------------------------

                .endsection
;-------------------------------------------------------------------------
                .section master_only
;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine for Master 128.
;
; Entry: A/X/Y/P as per OSBYTE or KEYV (according to entry point)
;
overlay_master: .block
                .cpu '65c02'
keyv_entry_offset=*-overlay_master
                lda #keyv_osbyte_number
osbyte_entry_offset=*-overlay_master
                php
                sei
                pha             ;save input A
rom_offset=*+1-overlay_master
                lda #$ff
                sta $fe30
hazel_offset=*+1-overlay_master
                lda #$ff
                jmp handle_overlay_master
                .endblock

                ; Unlikely
                .cerror size(overlay_master)>128,'Master overlay too large'
                
;-------------------------------------------------------------------------
;
; OSBYTE/KEYV overlay routine suffix for Master 128
;
; Entry: A = workspace address MSB
;        X/Y = as per OSBYTE
;        IRQs disabled
;        Stack = [A, P, OSBYTE ret]
; 
handle_overlay_master:
                ; Store workspace address LSB.
                sta os_seiwk+0

                ; Save input A.
                pla
                sta os_seiwk+1

                ; Save input P.
                pla
                sta os_seia

                ; Save previous ROMSEL.
                lda $f4
                pha
                
                ; Make ROMSEL and $f4 consistent.
                lda $fe30
                sta $f4

                ; Insert overlay exit routine addres.
                lda #>handle_overlay_exit_master-1
                pha
                lda #<handle_overlay_exit_master-1
                pha

                ; Put input P back on stack.
                lda os_seia
                pha

                ; Reinstate input A.
                lda os_seiwk+1

                jmp handle_osbyte_master

; Entry: A/X/Y/P as per OSBYTE/KEYV return
; Stack: [old ROMSEL, return address]
handle_overlay_exit_master:
                .cpu '65c02'
                pha
                php
                phx
                tsx
                ; S = X P A ROMSEL RetL RetH
                lda $104,x      ;ROMSEL
                pha             ;S = ROMSEL | X P A ROMSEL RetL RetH
                lda $102,x      ;P
                sta $104,x      ;S = ROMSEL | X P A P RetL RetH
                pla             ;S = | X P A P RetL RetH
                sta $102,x      ;S = | X ROMSEL A P RetL RetH
                plx             ;S = ROMSEL A P RetL RetH
                jmp os_restore_rom_master
                .cpu 'default'

;-------------------------------------------------------------------------
;
; Handle OSBYTE on Master 128 when called via extended vector.
;
; Entry: A/X/Y = as per OSBYTE
; 
handle_osbyte_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                pha
                phx
                ldx $f4
                lda $df0,x
                sta os_seiwk+0
                lda #>hazel_state_addr
                sta os_seiwk+1
                plx
                pla
                jmp handle_osbyte_master
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; KEYV xvector handler for Master 128
;
; Entry: just as per KEYV
handle_keyv_xvector_master: .proc
                .cpu '65c02'
                php
                sei
                pha
                phx
                ldx $f4
                lda $df0,x
                sta os_seiwk+0
                lda #>hazel_state_addr
                sta os_seiwk+1
                plx
                pla
                jmp keyv_master
                .cpu 'default'                
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE/KEYV handler for Master 128
; 
; Entry: A, X, Y = OSBYTE/KEYV entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]

handle_osbyte_master: .proc
                ; Don't use the OSBYTE zero page yet - it might be
                ; KEYV, possibly called from an interrupt context.
                cmp #keyv_osbyte_number
                beq keyv_master

                ; This is OSBYTE.
                sta os_a
                stx os_x
                sty os_y

                ; Form workspace address in (os_seiwk)
                ldx #>hazel_state_addr
                stx os_seiwk+1

                cmp #$80
                beq osbyte_80_master

                cmp #$81
                beq osbyte_81_master

                cmp #presence_osbyte_number
                beq osbyte_presence_generic
unhandled:
                ldx os_x
                ldy os_y
                plp
                jmp jmp_default_osbyte
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE $81 handler for Master 128.
;
; Entry: A = $81, ?os_a = $81
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
;
osbyte_81_master: .proc
                .cpu '65c02'

                ; Skip if jkeys bit not set.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda (os_seiwk)
                and #State.jflags.jkeys_mask
                cmp #1          ;C=1 if set
                pla
                sta acccon

                ; Defer to default OSBYTE if jkeys off.
                ldx os_x
                lda os_a
                ldy os_y
                bcc jmp_default_osbyte.with_p_already_pushed

                ; Go to timeout case if Y<$80
                bpl timeout

                ; Call default OSBYTE if Y!=$ff
                cpy #$ff
                bne jmp_default_osbyte.with_p_already_pushed

                ; Call default OSBYTE for the X=$00 Y=$FF version
                ; call.
                cpx #0
                beq jmp_default_osbyte.with_p_already_pushed

                ; Is this one of the jkeys?
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda #1
                sta os_y
                ldy #State.action_keys

                lda os_x
                eor #$ff        ;convert to internal key
poll_key_loop:
                cmp (os_seiwk),y
                beq found_key
                asl os_y
                iny
                cpy #State.action_keys+num_actions
                bne poll_key_loop
not_found_key:
                pla
                sta acccon

                lda #$81
                ldy #$ff
                ldx os_x
                
                jmp jmp_default_osbyte.with_p_already_pushed

found_key:
                lda (os_seiwk)
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and os_y
                beq not_found_key

                pla
                sta acccon
                ldx #$ff
                ldy #$ff
                lda #$81
                plp
                rts

timeout:
                ; Y/X = timeout value

loop:
                ; Save timeout.
                pla             ;old IRQ state [RL RH]
                pha             ;save old IRQ state [P RL RH]
                phy             ;[TH P RL RH]
                phx             ;[TL TH P RL RH]
                pha             ;save old IRQ state again [P TL TH P RL RH]

                ; Read joystick.
                lda acccon
                pha             ;[ACCCON P TL TH P RL RH]
                lda #acccon.ifj|acccon.y
                tsb acccon
                lda (os_seiwk)
                and #3
                tay
                ldx joystick_fred_offsets,y
                lda $fc00,x
                and #jall_mask
                beq try_osbyte  ;taken if obviously nothing pressed

                ; Find state offset for action.
                ;
                ; TODO: there'll probably be room to have this in a
                ; table.
                ldy #State.action_keys-1
find_index_loop:
                iny
                lsr a
                bcc find_index_loop

                lda (os_seiwk),y
                bpl jkey_pressed
                
try_osbyte:
                
                pla             ;[P TL TH P RL RH]
                sta acccon
                
                lda os_seiwk+0
                plp             ;Restore IRQ state [TL TH P RL RH]
                pha             ;Save workspace ptr MSB [WH TL TH P RL RH]

                ; X=0 if (TL|TH)==0, else X=1
                tsx
                lda $102,x      ;TL
                ora $103,x      ;TL|TH
                tax
                beq +
                ldx #1
+
                ldy #0
                lda #$81
                jsr jmp_default_osbyte
                cpy #$ff
                bne kkey_pressed

                ; lda #1
                ; sta os_auto_repeat_countdown

                ; Restore state.
                pla             ;Restore workspcae ptr MSB [TL TH P RL RH]
                sei
                sta os_seiwk+0
                lda #>hazel_state_addr
                sta os_seiwk+1

next:
                ; Decrement timeout, and keep going until 0.
                plx             ;[TH P RL RH]
                ply             ;[P RL RH]
                cpx #0
                bne no_carry
                ; X=0
                cpy #0
                beq timed_out
                ; Y>0
                dey
no_carry:
                dex
                jmp loop

timed_out:
                ; X=0, Y=0. Timed out. Return with C=1 and Y=$ff.
                plp             ;[RL RH]
                dey
                sec
                rts
                .cpu 'default'

kkey_pressed:
                pla             ;discard workspace ptr MSB [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore IRQ state [RL RH]
                lda #$81        ;A is preserved
                clc
                rts

jkey_pressed:
                cmp #16
                bcc try_osbyte  ;definitely not ASCII
                tay
                lda key_chars_table-16,y ;A=ASCII value of key pressed
                bmi try_osbyte           ;bail if not ASCII
                bne +                    ;taken if TAB
                lda os_tab_key_code      ;adjust TAB code
+
                ; The Slogger ROM doesn't handle shift, ctrl, caps
                ; lock, etc., so this one doesn't either.

                tax             ;X = ASCII Value of key pressed
                pla             ;get old ACCCON value [P X Y P RL RH]
                sta acccon
                pla             ;discard old IRQ state copy [X Y P RL RH]
                pla             ;discard counter LSB [Y P RL RH]
                pla             ;discard counter MSB [P RL RH]
                plp             ;restore old IRQ state [RL RH]
                lda os_a
                ldy #0
                clc
                rts
                
                .endproc

;-------------------------------------------------------------------------
;
; OSBYTE $80 handler for Master 128.
;
; Entry: A = $80, ?os_a = $80
;        ?os_x, ?os_y = OSBYTE $80 entry arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
; 
osbyte_80_master: .proc
                ; Bail if not ADVAL.
                ldx os_x
                cpx #5
                bcs handle_osbyte_master.unhandled
                
                .cpu '65c02'
                ; Save old ACCCON. Page in HAZEL. Direct FRED to
                ; cartridge.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Fetch joystick index.
                ldy #State.jflags
                lda (os_seiwk),y
                bit #State.jflags.jjoy_mask
                beq default
                and #3

                ; ?os_a = joystick value
                tay
                lda joystick_fred_offsets,y
                tay
                lda $fc00,y
                sta os_a

                ; Restore old ACCCON.
                pla
                sta acccon

                ; OK to possibly re-enable IRQs now.
                plp
                
                jmp osbyte_80_generic
                .cpu 'default'

default:
                pla
                sta acccon
                lda os_a
                jmp handle_osbyte_master.unhandled
                .endproc
;-------------------------------------------------------------------------
;
; KEYV handler for Master 128.
;
; Entry: A = keyv_osbyte_number
;        X, Y = KEYV arguments
;        (os_seiwk) = pointer to workspace in HAZEL
;        IRQs disabled
;        Stack: [Input P; appropriate return address]
keyv_master: .proc
                .cpu '65c02'
                pla             ;restore P
                pha             ;re-save P
                and #%01000001  ;separate C+V
                cmp #%00000001  ;check for C=1 V=0
                beq scan

                ; Forward to default KEYV.
                jmp jmp_default_keyv.with_p_already_pushed

scan:
                sta os_a
                sty os_y
                
                ; Form workspace address in (os_seiwk)
                lda #>hazel_state_addr
                sta os_seiwk+1

                ; Check for keyboard scan mode.
                txa
                bpl scan_multiple_keys ;taken if scanning for multiple
                                       ;keys

scan_single_key: .block
                ; Convert to internal key number.
                and #$7f
                sta os_x
                
                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags into X
                lda (os_seiwk)
                bit #State.jflags.jkeys_mask
                beq default
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y

                ldy #State.action_keys+num_actions-1
loop:
                lda os_x        ;key of interest
                cmp (os_seiwk),y
                bne next        ;taken if not this jkey
                txa             ;get joystick flags
                and joystick_actions.masks-State.action_keys,y
                bne pressed     ;taken if this jkey pressed
next:
                dey
                bne loop

default:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Key was not one of the joystick keys, so forward the
                ; call on to KEYV.
                lda os_x
                ora #$80        ;reinstate bit 7, masked out above
                tax
                lda os_a
                ldy os_y
                jmp jmp_default_keyv.with_p_already_pushed

pressed:
                ; Restore ACCCON.
                pla
                sta acccon

                ; Report key pressed.
                lda os_a
                ldx #$ff
                ldy os_y
                plp
                rts
                .endblock
                
scan_multiple_keys: .block
                phx
                lda os_seiwk+0
                pha
                sec
                clv
                jsr jmp_default_keyv

                ; Save KEYV result.
                stx os_y

                ; Restore old state: IRQs disabled, os_seiwk set up,
                ; os_x as per entry.
                sei
                lda #>hazel_state_addr
                sta os_seiwk+1
                pla
                sta os_seiwk+0
                pla
                sta os_x

                ; Set up ACCCON.
                lda acccon
                pha
                lda #acccon.ifj|acccon.y
                tsb acccon

                ; Read joystick flags.
                lda (os_seiwk)
                and #3
                tax
                ldy joystick_fred_offsets,x
                ldx $fc00,y
                ldy #State.action_keys+num_actions-1
loop:
                txa             ;A=joystick flags
                and joystick_actions.masks-State.action_keys,y
                beq next        ;taken if not pressed

                lda (os_seiwk),y ;get key for this action
                cmp os_x         ;within scan range?
                bcc next         ;taken if not
                beq next         ;taken if not
                cmp os_y         ;existing result covers it?
                bcs next         ;taken if so
                sta os_y

next:
                dey
                bne loop

                ; Restore old ACCCON.
                pla
                sta acccon

                ldx os_y
                lda os_a
                plp
                rts
                .endblock
                .endproc
;-------------------------------------------------------------------------
;
; Exit: Stack = [old_ACCCON old_P]
;       IRQs disabled
;       (os_seiwk) points to workspace
; Preserves: A/X/Y
setup_acccon_master: .proc
                .cpu '65c02'
                pha
                php
                pha
                phx
                tsx

                ;
                ; | Addr   | Before | After |
                ; |--------|--------|-------|
                ; | $101,x | old X  | old X
                ; | $102,x | old A  | old A
                ; | $103,x | old P  | retL
                ; | $104,x | old A  | retH
                ; | $105,x | retL   | old ACCCON
                ; | $106.x | retH   | old P

                lda $106,x
                sta $104,x
                lda $103,x
                sta $106,x
                lda $105,x
                sta $103,x
                lda acccon
                sta $105,x

                sei
                lda #acccon.ifj|acccon.y
                tsb acccon

                ldx $f4
                lda $df0,x
                sta os_seiwk+0
                lda #>hazel_state_addr
                sta os_seiwk+1

                pla
                plx
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
                .endsection master_only
;-------------------------------------------------------------------------
                .section common
;-------------------------------------------------------------------------
;
; Entry: X = offset into questions table
; Exit: Y = index of option
;       C=1 if Escape pressed
question: .proc
                .section question_workspace
char_entered: .fill 1
                .endsection

                jsr print_string ;question

                txa
                pha             ;save options offset
                
                jsr print_following_string
                .text ' (',0

                jsr print_string ;options

                jsr print_following_string
                .text ')? ',0

read_option_loop:
                jsr osrdch
                bcs quit
                
                jsr toupper
                sta char_entered

                ; Y = option index
                ldy #0

                ; X = option offset
                pla
                pha
                tax
find_option_loop:
                lda questions_table,x
                lsr a
                php
                
                ; Cheaper to include the '/' in the option string, but
                ; now it does have to be excluded.
                cmp #'/'
                beq next
                
                cmp char_entered
                beq found

                iny
next:
                inx
                plp
                bcc find_option_loop
                bcs read_option_loop

found:
                jsr oswrch
                jsr osnewl
                pla             ;discard saved P
                clc             ;indicate Escape not pressed
quit:
                pla             ;discard saved options offset
                rts

print_string:
                lda questions_table,x
                jsr shiftl_oswrch
                inx
                bcc print_string
                rts
                
                .endproc

;-------------------------------------------------------------------------
;
; Call OSWRCH with a .shiftl char.
;
; Entry: A = shiftl char
; Exit: A = ASCII value
;       C=1 if it was the terminator
; Preserves: X/Y
shiftl_oswrch: .proc
                lsr a
                php
                jsr oswrch
                plp
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Handle presence OSBYTE.
;
; Entry: A = presence_osbyte_number
;        X/Y = whatever
;        Stack = [P RetL RetH]
osbyte_presence_generic: .proc
                ldy #State.jflags
                jsr read_state
                tay
                ldx #'A'
                lda #presence_osbyte_number
                plp
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Handle OSBYTE $80, X<=4
;
; Entry: ?os_a = value read from joystick
;        X = X value for OSBYTE $80 call
;        
osbyte_80_generic: .proc
                cpx #0
                beq test_fire

                ldy #$00        ;probably correct...

                lda os_a
                and max_value_masks-1,x
                bne max_value

                lda os_a
                and min_value_masks-1,x
                bne min_value

zero:
                ldx #$00
                ldy #$80
                rts

max_value:
                ldx #$ff
                dey             ;Y=$ff
                rts

min_value:
                ldx #$00
                rts

test_fire:
                ldy #4          ;fake last ADC conversion channel
                ; X=0 - assume no buttons pressed
                
                lda os_a
                and #jall_fire_mask
                beq +
                inx             ;X=1
+
                rts

min_value_masks: .byte jright_mask,jdown_mask,0,0
max_value_masks: .byte jleft_mask,jup_mask,0,0
                .endproc

;-------------------------------------------------------------------------
;
; Sets jflags bits: jkeys set, jjoy clear, jindex set.
;
; Entry: A = new values for jindex, jkeys, jjoy
; Preserves: X
set_jflags: .proc
                .section set_jkeys_mode_workspace
set_bits: .fill 1
                .endsection
                sta set_bits
                ldy #State.jflags
                jsr read_state
                and #~(State.jflags.jindex_mask|State.jflags.jkeys_mask|State.jflags.jjoy_mask)
                ora set_bits
                jmp write_state
                .endproc
               
;-------------------------------------------------------------------------
;
; Print joystick action name, padded on the right with spaces.
;
; Entry: X = joystick action index, or $FF for blank
print_joystick_action_name: .proc
                .section print_joystick_action_name_workspace
pja_index: .fill 1
                .endsection

                inx
                stx pja_index
                txa
                asl a           ;*2, C=0
                asl a           ;*4, C=0
                adc pja_index   ;*5
                tay
print:
                ldx #4
-
                lda joystick_actions.names,y
                jsr oswrch
                iny
                dex
                bpl -
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Parse <no> argument from command line. Does a BRK for invalid
; joystick numbers.
;
; Entry: ($f2),y = command line pointer
; Exit: ($f2),y = updated command line pointer
;       A = joystick index, 0-3
parse_jno: .proc
                jsr strtoi
                sec
                sbc #1
                cmp #4
                bcc +
                ldx #errors_table.bad_jno_offset
                jmp do_error
+
                rts
                .endproc
;
;-------------------------------------------------------------------------
;
; Wait for a keypress. Print the pressed key's name.
;
; Exit: X = INKEY value of key pressed
verbose_get_key: .proc
                .section verbose_get_key_workspace
kindex: .fill 1
num_keys: .fill 1
                
; if bit 7 set, waiting for no keys pressed.
waiting_for_no_keys: .fill 1
                .endsection

                lda #num_electron_keys
                jsr is_valid_hw
                bvc +
                lda #num_master_keys
+
                sta num_keys

                sec
main_loop:
                ror waiting_for_no_keys

                ldx #0
keys_loop:
                stx kindex
                lda key_inkey_numbers_table,x
                pha             ;save INKEY number
                ora #$80        ;form true INKEY number
                tax
                lda #$81
                ldy #$ff
                jsr osbyte
                pla             ;restore INKEY number
                
                cpx #$ff        ;C=1 if pressed
                beq pressed     ;taken if pressed

                ldx kindex
                inx
                cpx num_keys
                bne keys_loop

                ; The end of the table is only reached if no keys
                ; pressed. So arrange for waiting_for_no_keys to get
                ; reset when repeating.
                clc
                bcc main_loop

pressed:
                ; If it's escape, sort it out.
                cmp #inkey(key_escape)
                bne not_escape_pressed

                lda #$7d        ;Set Escape condition (AUG p148)
                jmp osbyte

not_escape_pressed:
                ; If still waiting for no keys, go right back to the
                ; start. The flag will remain set.
                bit waiting_for_no_keys
                bmi verbose_get_key

                cmp #$80        ;C=1 if name is string table offset
                ora #$80        ;form true INKEY number
                tax             ;X=INKEY number

                ldy kindex
                lda key_names_table,y
                bcs string_name

                ; Name is 1 char
                jmp oswrch

string_name:
                ; Name is multiple chars
                tay
string_name_loop:
                lda key_strings_table,y
                jsr shiftl_oswrch
                iny
                bcc string_name_loop
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Return value indicating whether hardware type is valid.
;
; Exit: C=1 if valid type:
;            V=0 if Electron
;            V=1 if Master
;       C=0 if invalid type
; Preserves: A/X/Y
is_valid_hw: .proc
                pha
                txa
                pha
                tya
                pha
                ; https://beebwiki.mdfs.net/OSBYTE_%2600
                lda #0
                ldx #1
                jsr osbyte
                cpx #0
                beq electron
                cpx #3
                beq master
                ; Not valid
                clc
                jmp done

electron:
                clv
                bvc done        ;i.e., JMP
master:
                bit sev_value
done:
                pla
                tay
                pla
                tax
                pla
                rts
                .endproc
                
;-------------------------------------------------------------------------
;
; Check valid hardware, doing a BRK if not valid.
;
; Exit: C=1 - same as is_valid_hw
;       Will do a BRK if any other values
;
must_be_valid_hw: .proc
                jsr is_valid_hw
                bcc error
                rts
error:
                ldx #errors_table.incompatible_hw_offset
                jmp do_error
                
                .endproc

;-------------------------------------------------------------------------

                .section read_or_write_state_workspace
state_ptr: .fill 2
                .endsection

;-------------------------------------------------------------------------
;
; Set up state_ptr for the Master.
;
; Exit: (state_ptr) = pointer to state in HAZEL
; Preserves: A/X/Y/C
set_up_state_ptr_master: .proc
                .cpu '65c02'
                pha
                phx
                ldx $f4
                lda $df0,x
                sta state_ptr+0
                lda #>hazel_state_addr
                sta state_ptr+1
                plx
                pla
                rts
                .cpu 'default'
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read 1 byte from the ROM state.
;
; Entry: Y = offset into State struct
; Exit: A = value read
; Preserves: X/Y
read_state: .proc
                jsr must_be_valid_hw
                bvs master

electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                lda $200,x
                ldx state_ptr+0
                rts

master:
                jsr set_up_state_ptr_master
                lda (state_ptr),y
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Write 1 byte to the ROM state.
;
; Entry: A = value to write
;        Y = offset into State struct
; Preserves: A/X/Y
write_state: .proc
                jsr must_be_valid_hw
                bvs master

electron:
                stx state_ptr+0
                ldx elk_state_offsets,y
                sta $200,x
                ldx state_ptr+0
                rts

master:
                jsr set_up_state_ptr_master
                sta (state_ptr),y
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Restore default BYTEV and KEYV vectors.
;
; Preserves: P/A/X/Y

reset_default_vectors: .proc
                .section reset_default_vectors_workspace
rdv_ptr: .fill 2
                .endsection
                
                php
                sei
                tya
                pha

                lda default_vectors_ptr+0
                sta rdv_ptr+0
                lda default_vectors_ptr+1
                sta rdv_ptr+1

                ldy #<bytev
                jsr restore_default_vector

                ldy #<keyv
                jsr restore_default_vector

                lda #0
                sta os_break_intercept+0

                ldy #State.jflags
                jsr read_state
                and #~(State.jflags.jjoy_mask|State.jflags.jkeys_mask)
                jsr write_state

                pla
                tay
                plp
                rts

restore_default_vector:
                jsr restore_default_vector_byte
restore_default_vector_byte:
                lda (rdv_ptr),y
                sta $200,y
                iny
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick: .proc
                jsr is_valid_hw
                lda #0
                bcc done
                bvc read_joystick_elk
                bvs read_joystick_master
done:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Master.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_master: .proc
                .cpu '65c02'
                php
                sei
                lda acccon
                pha
                lda #acccon.ifj
                tsb acccon
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                plx
                stx acccon
                plp
                rts
                .cpu 'default'
                .endproc

;-------------------------------------------------------------------------
;
; Read joystick on Electron.
;
; Entry: X = joystick index, 0-3
; Exit: A = value read
; Preserves: Y
read_joystick_elk:
                lda joystick_fred_offsets,x
                tax
                lda $fc00,x
                rts

;-------------------------------------------------------------------------
                .endsection common
;-------------------------------------------------------------------------
                .section library
;-------------------------------------------------------------------------
; 
; jmp_default_osbyte
;
jmp_default_osbyte: .proc
                php
with_p_already_pushed:
                sei
                sty os_seia         ;caution
                ldy #<bytev
                bne jmp_default_vector_routine
                .endproc
                
jmp_default_keyv: .proc
                php
with_p_already_pushed:
                sei
                sty os_seia         ;caution
                ldy #<keyv
                .cerror *!=jmp_default_vector_routine,'fallthrough broke'
                .endproc
jmp_default_vector_routine: .proc
                pha
                lda default_vectors_ptr+0
                sta os_seiwk+0
                lda default_vectors_ptr+1
                sta os_seiwk+1
                lda (os_seiwk),y ;routine LSB
                pha
                iny
                lda (os_seiwk),y ;routine MSB
                sta os_seiwk+1
                pla
                sta os_seiwk+0
                ldy os_seia
                pla

                ; If PLP re-enables interrupts, the next instruction
                ; still always executes, even if there's an interrupt
                ; pending. (PLP's IRQ check comes before the register
                ; is updated.) So this use of os_seiwk is quite safe.
                plp
                jmp (os_seiwk)
                .endproc

;-------------------------------------------------------------------------
;
; Read 8-bit integer from string.
;
; Entry: ($f2),y = pointer to string
; Exit: A = LSB of value read
;       ($f2),y = pointer to remainder of string
; Preserves: X
                .section strtoi_workspace
strtoi_value: .fill 2
                .endsection
                
strtoi:         .proc
                jsr find_string_tail
                beq bad_hex
                lda #0
                sta strtoi_value+0
                sta strtoi_value+1
                jsr gsread      ; EAUG p12
                bcs bad_hex     ; taken if eol
                cmp #'&'
                bne decimal
; hex value
                jsr gsread
                bcs bad_hex     ; taken if eol
                bcc got_digit   ; JMP, in effect

hex_loop:
                jsr gsread
                bcs done        ; taken if eol

got_digit:
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex     ; taken if input error
; strtoi_value<<=4
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl strtoi_value+0
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value|=digit
                adc strtoi_value+0
                sta strtoi_value+0
                bcc hex_loop    ; always a JMP???

done:
                lda strtoi_value+0
                rts

;-------------------------------------------------------------------------

bad_hex:
                ldx #errors_table.bad_hex_offset
                jmp do_error

;-------------------------------------------------------------------------

decimal:
                cmp #'-'
                php             ; save negative flag - Z=1 if negative
                bne decimal_loop
                jsr gsread
                bcs bad_hex

decimal_loop:
                jsr atoi_1_digit; Convert 1 decimal digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs bad_hex
                pha             ; save digit value
                lda strtoi_value+1
                pha             ; save value MSB
                lda strtoi_value
; strtoi_value=strtoi_value*2
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
                asl a
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=strtoi_value*2+strtoi_value -> strtoi_value*5
                adc strtoi_value+0
                sta strtoi_value+0
                pla             ; restore value MSB
                adc strtoi_value+1
                sta strtoi_value+1
                bcs bad_hex     ; taken if overflow
; strtoi_value=(strtoi_value*2+strtoi_value)*2 -> strtoi_value*5*2 -> strtoi_value*10
                asl strtoi_value
                rol strtoi_value+1
                bcs bad_hex     ; taken if overflow
; add in digit
                pla             ; restore digit value
                adc strtoi_value+0
                sta strtoi_value+0
                bcc L953D
                inc strtoi_value+1
                beq bad_hex     ; taken if overflow

L953D:
                jsr gsread
                bcc decimal_loop; taken if not eol
                plp             ; restore negative flag
                bne L9552    ; taken if positive
; strtoi_value=-strtoi_value
                sec
                lda #0
                sbc strtoi_value+0
                sta strtoi_value+0
                lda #0
                sbc strtoi_value+1
                sta strtoi_value+1

L9552:
                lda strtoi_value+0
                rts
                .endproc

;-------------------------------------------------------------------------

; Convert 1 decimal digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
atoi_1_digit:   .proc
                jsr xtoi_1_digit; Convert 1 hex digit to a value
                                ; Entry: A = ASCII digit
                                ; Exit:  A = value
                                ;        C=1 if digit was invalid
                bcs L955C
                cmp #$A

L955C:
                rts
                .endproc

;-------------------------------------------------------------------------

; Convert 1 hex digit to a value
; Entry: A = ASCII digit
; Exit:  A = value
;        C=1 if digit was invalid
; Preserves: X/Y
xtoi_1_digit:   .proc
                cmp #'A'
                bcc L9563
                sbc #7

L9563:
                sec
                sbc #'0'
                cmp #$10
                rts
                .endproc

;-------------------------------------------------------------------------
;
print_bool: .proc
                cmp #1
                .fall_through_to print_c
                .endproc
print_c: .proc
                lda #'0'
                adc #0
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
;
;
print_hex_byte: .proc
                pha
                lsr a
                lsr a
                lsr a
                lsr a
                jsr nybble
                pla
                pha
                and #$0f
                jsr nybble
                pla
                rts

nybble:
                sed
                clc
                adc #$90
                adc #$40
                cld
                jmp oswrch
                .endproc
                
;-------------------------------------------------------------------------
; 
; Try to find command in commands table
; Entry: ($f2),y = pointer to string
;        X = offset into command_table
; Exit: C=0 if command found
;       X = offset of routine address
;           (ready for call_command_table_routine)
find_command: .proc
                .section find_command_workspace
fc_table_offset: .fill 1
fc_string_offset: .fill 1
                .endsection
                
                stx fc_table_offset
                clc
                jsr find_string_tail; Check if command line tail is empty.
                                   ; Entry: ($f2),y = command line tail
                                   ; Exit:  C=0 - something on command line
                                   ;        C=1 - nothing on command line
                sty fc_string_offset

L9245:
                ldy fc_string_offset
                dex
                dey

L9249:
                inx
                iny
                lda command_table,x
                sec
                beq done        ; taken if end of table reached
                bmi L9269
                eor ($F2),y
                and #$5F
                beq L9249
                lda ($F2),y
                cmp #'.'
                beq L9271

L925F:
                inx
                lda command_table,x
                bpl L925F       ; taken if end of command name reached

L9265:
                inx
                inx
                inx
                bne L9245

L9269:
                lda ($F2),y
                jsr isalpha     ; Check if char is alphabetic
                                ; Entry: A = char of interest
                                ; Exit:  C=0 if alpha, C=1 if not alpha
                bcc L9265       ; taken if alpha
                dey

L9271:
                iny
                dex

L9273:
                inx
                lda command_table,x
                bpl L9273
                clc

done:
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Convert char to upper case.
; 
toupper: .proc
                cmp #'a'
                bcc +
                cmp #'z'+1
                bcs +
                and #$df
+
                rts
                .endproc
                
;-------------------------------------------------------------------------

; Check if char is alphabetic
; Entry: A = char of interest
; Exit:  C=0 if alpha, C=1 if not alpha

isalpha:        .proc
                pha             ; store char
                and #$DF        ; convert lower case to upper case
                cmp #'A'
                bcc not_alpha   ; taken if not alpha
                cmp #'Z'+1
                bcc done        ; taken if alpha

not_alpha:
                sec

done:
                pla             ; restore char
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Print 0-terminated string following call.
;
; Preserves: X
print_following_string: .proc
                .section print_following_string_workspace
pfs_ptr: .fill 2
                .endsection

loop:
                ; inc address on stack and store in pfs_ptr
                clc
                pla
                adc #1
                sta pfs_ptr+0
                tay
                pla
                adc #0
                sta pfs_ptr+1
                pha
                tya
                pha

                ; fetch next byte from string
                ldy #0
                lda (pfs_ptr),y
                beq done
                jsr oswrch
                jmp loop

done:
                rts
                
                .endproc                

;-------------------------------------------------------------------------
;
; Cause an error.
;
; Entry: X = offset of error data in errors_table
do_error: .proc
                ldy #0
                sty brkbuf
                dex
                dey

L935E:
                inx
                iny
                lda errors_table,x
                sta brkbuf+1,y
                bne L935E
                jmp brkbuf
                .endproc
                
;-------------------------------------------------------------------------
;
; Find string tail.
; Entry: ($f2),y = string pointer
; Exit: C=0 - something on command line, ($f2),y points to it, A=first char
;       C=1 - nothing on command line, ($f2),y points to end, A=13
; Preserves: X
retry_find_string_tail:
                iny
find_string_tail:
                lda ($f2),y     ; read next value from command line
                cmp #13
                beq _done       ; taken with C=1 if eol
                cmp #' '
                beq retry_find_string_tail ; taken with C=1 if space -
                                          ; move to next byte and try
                                          ; again
                clc
_done:
                rts

;-------------------------------------------------------------------------
;
; Call found command's command table routine.
; Entry: X = offset into command table of MSB of command routine
call_command_table_routine: .proc
                lda command_table,x
                pha
                lda command_table+1,x
                pha
                rts
                .endproc

;-------------------------------------------------------------------------
;
; Switch cursor on (con) or off (coff)
; 
con:
                ldx #con_vdu-cset_vdu
                jmp cset
coff:
                ldx #coff_vdu-cset_vdu
cset:
                ldy #10
cset_loop:
                lda cset_vdu,x
                jsr oswrch
                inx
                dey
                bne cset_loop
                rts
                
cset_vdu:
con_vdu:                        ;TODO could live in keyboard table
                .byte 23,1,1
coff_vdu:                       ;TODO could live in keyboard table
                .byte 23,1,0
                ; doens't matter what comes next...
                
;-------------------------------------------------------------------------
                .endsection library
;-------------------------------------------------------------------------

                .if debug

; The debug stuff prints DOS-style line endings, so 13,10 rather than
; 10,13. Looks the same on the screen, but saves a moment when loading
; the SPOOLed output into Emacs, which has apparently no way of
; supporting Acorn-style 2-byte line endings.
                
                .section debug

debug_num_stack_bytes=24

;-------------------------------------------------------------------------

cmd_dtest:
                jsr debug_store_state
                jsr debug_print_info
                rts

;-------------------------------------------------------------------------

cmd_dreset:
                lda #<debug_buffer
                sta debug_dest+0
                lda #>debug_buffer
                sta debug_dest+1
                jsr debug_print_info
                rts

;-------------------------------------------------------------------------

debug_print_info:
                jsr print_following_string
                .text 'debug_buffer=&'
                .text format('%04X',debug_buffer)
                .text 13,10     ;DOS-style
                .text 'dest=&',0

                lda debug_dest+1
                jsr print_hex_byte
                lda debug_dest+0
                jsr print_hex_byte

                jmp debug_newl

;-------------------------------------------------------------------------

debug_newl:
                lda #13
                jsr oswrch
                lda #10
                jsr oswrch
                rts
                
;-------------------------------------------------------------------------

cmd_ddump: .proc
                .section cmd_ddump_workspace
ptr: .fill 2
s_value: .fill 1
                .endsection
                
                jsr debug_print_info
                
                lda #>debug_buffer
                sta ptr+1
                lda #<debug_buffer
                sta ptr+0

records_loop:                
                jsr eod
                bcs done

                ; 0123456789012345678901234567890123456789
                ; A=&xx X=&xx Y=&xx S=&xx P=&xx
                jsr print_following_string
                .text 'A=&',0
                jsr read_and_print_byte
                
                jsr print_following_string
                .text ' X=&',0
                jsr read_and_print_byte
                
                jsr print_following_string
                .text ' Y=&',0
                jsr read_and_print_byte
                
                jsr print_following_string
                .text ' P=&',0
                jsr read_and_print_byte
                
                jsr print_following_string
                .text ' S=&',0
                jsr read_and_print_byte
                sta s_value
                
                jsr debug_newl

                ldx #0
stack_loop:
                jsr print_following_string
                .text ' &',0
                
                clc
                txa
                adc s_value
                pha
                lda #1
                adc #0
                jsr print_hex_byte
                pla
                jsr print_hex_byte
                
                jsr print_following_string
                .text ': ',0

                jsr read_a
                jsr print_hex_byte

                jsr print_following_string
                .text ' : ',13,10,0

                inx
                cpx #debug_num_stack_bytes
                bne stack_loop
                jsr debug_newl
                jmp records_loop
                
done:
                rts

read_and_print_byte:
                jsr read_a
                jmp print_hex_byte

read_a: .proc
                jsr eod
                bcs _null
                ldy #0
                lda (ptr),y
                inc ptr+0
                bne _done
                inc ptr+1
_done:
                rts
_null:
                lda #0
                rts
                .endproc

eod: .proc
                lda ptr+1
                cmp debug_dest+1
                bne _done        ;exit with C=1 (gt) or C=0 (lt)
                lda ptr+0
                cmp debug_dest+0 ;C=1 (ge) or C=0 (lt)
_done:
                rts
                .endproc

                .endproc

;-------------------------------------------------------------------------

debug_store_state: .proc
                php             ;4
                pha             ;3
                txa             ;2
                pha
                tya             ;1
                pha

                tsx
                lda $103,x      ;A
                jsr debug_store_a
                lda $102,x      ;X
                jsr debug_store_a
                lda $101,x      ;Y
                jsr debug_store_a
                lda $104,x      ;P
                jsr debug_store_a
                txa
                clc
                adc #7          ;P+A+X+Y+ret address+1
                jsr debug_store_a ;S
                tax
                ldy #debug_num_stack_bytes
loop:
                lda $100,x
                jsr debug_store_a
                inx
                dey
                bne loop

                pla
                tay
                pla
                tax
                pla
                plp
                rts
                .endproc
                
debug_store_a: .proc
                ; skip if no space left
                bit debug_dest+1
                bvs done
sta_debug_buffer:
                sta debug_buffer
                inc debug_dest+0
                bne done
                inc debug_dest+1
done:
                rts
                .endproc

debug_dest=debug_store_a.sta_debug_buffer+1

;-------------------------------------------------------------------------

debug_buffer:
                .endsection debug
                
                .endif
                